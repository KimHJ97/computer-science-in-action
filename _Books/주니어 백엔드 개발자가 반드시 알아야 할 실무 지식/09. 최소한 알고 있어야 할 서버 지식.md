# 최소한 알고 있어야 할 서버 지식

 - OS 계정과 권한
 - 프로세스
 - 디스크 용량
 - 파일 디스크립터 제한
 - 시간 동기화
 - 크론을 이용한 스케줄링
 - 별칭
 - 네트워크 정보 확인

<br/>

## 1. OS 계정과 권한

서버 프로그램의 프로세스를 중지시켰다가 다시 실행했는데 프로세스가 구동되지 않은 적이 있다. 원인은 프로세스가 생성한 파일에 있었다. 직전에 root 계정으로 프로세스를 구동했고 그 프로세스가 파일을 생성했다. 이후 일반 사용자 계정으로 프로세스를 다시 구동했는데, 일반 계정은 root 계정으로 생성한 파일을 수정할 권한이 없었다. 프로세스 시작 과정에서 파일 수정에 실패하면서 프로세스는 비정상 종료됐다.

root 계정은 OS를 설치하면 기본 생성되는 계정으로 모든 권한을 가진 관리자 계정이다. 보통 인프라 담당자만 root 계정 접근 권한을 갖고 나머지 개발자는 별도로 생성한 사용자 계정을 이용해서 서버에 연결한다.

 - 파일 권한
    - r: 읽기 권한
    - w: 쓰기 권한
    - x: 실행 권한
```bash
# 소유자: 모든 권한, 그룹: 읽기와 실행, 다른 계정: 읽기
chmod 754 run.sh

# u: 소유자, g: 그룹, o: 다른사용자, a: 모두
# +: 추가, -: 제거, =: 지정
# r: 읽기, w: 쓰기, x: 실행
```
<br/>

### 1-1. sudo로 권한 주기

일반적으로 운영체제의 root 권한은 인프라 담당자만 갖고, 개발자는 일반 계정에 대한 권한만 갖는다. 개발자는 이 계정으로 톰캣과 같은 다른 서비스를 관리한다.

개발자도 root 권한이 필요할 때가 있는데, 필요할 때마다 매번 인프라 담당자한테 작업 요청을 하면 업무 효율이 떨어진다. 반대로 개발자한테 root 권한을 부여하면 보안 측면에서 위험할 수 있다. 이때 사용할 수 있는 것이 sudo 명령이다.

 - sudo 명령어를 사용하면 다른 사용자의 권한으로 프로그램을 실행할 수 있다.
 - sudo 명령어로 실행할 수 있는 명령어는 별도 설정 파일로 관리한다.
    - "/etc/sudoers", "/etc/sudoers.d" 디렉토리에 위치한 파일
 - sudoers 파일을 수정할 떄는 visudo 명령어를 사용한다.
```bash
# sudoers 파일 내용
# root 계정은 -> 모든 호스트에 대해 -> 모든 사용자로 실행할 수 있다. -> 모든 명령어를 실행할 수 있다.
root    ALL=(ALL) ALL

# user1에게 특정 명령어 실행 권한 부여
user1   ALL=(ALL) NOPASSWD: /usr/bin/systemctl
```
<br/>

## 1-2. 프로세스 확인하기

클라이언트가 서버에 연결이 제대로 안 되면 서버 프로세스가 정상 동작 중인지 확인해야 한다. 서버 프로그램을 재시작하는데 이전 프로세스가 종료되지 않고 남아 있다거나, 시작하는 과정에서 오류가 발생해서 프로세스 구동에 실패할 때가 발생할 수 있기 때문이다.

```bash
# 프로세스 ID 확인
$ ps aux
$ ps -eaf

# CPU, 메모리 사용량 확인
$ top
$ htop

# 메모리 사용량이 높은 프로세스 상위 5개 확인
$ ps aux --sort -rss | head -n 6
```
<br/>

## 1-3. 프로세스 종료

프로세스를 종료할 때는 kill 명령어를 사용한다. kill 명령어는 명령행 인자로 프로세스 ID를 사용한다.

 - "-15", "-s SIGTERM", "-TERM"
    - 기본값으로 프로세스에 TERM 신호를 보낸다.
    - TERM 신호를 받은 프로세스는 종료에 필요한 작업을 수행한다.
    - 예를 들어 임시로 생성한 파일을 삭제하거나, 스프링 빈의 제거 처리를 하는 작업을 수행한다.
 - "-9", "-s SIGKILL", "-KILL"
    - 프로세스를 강제로 종료한다.
    - 이 옵션은 프로그램이 종료할 때 수행하는 정리 작업을 할 수 없기 때문에 주의해서 사용해야 한다.

<br/>

## 2. 백그라운드 프로세스

tail, top, vi처럼 서버에 접속한 뒤 터미널에서 실행하는 프로그램은 기본적으로 포그라운드 프로세스로 실행된다. 포그라운드 프로세스는 터미널에 연결된 프로세스로, 키보드나 스크린을 통해 사용자와 상호작용한다. 포그라운드 프로세스는 터미널과 연결되어 있기 때문에 사용자와 터미널의 연결이 끊기면 종료된다.

백그라운드 프로세스는 터미널과 연결되지 않은 프로세스를 말한다. 터미널과 연결되어 있지 않으므로 키보드나 스크린을 통해 사용자와 상호작용할 수 없다. 리눅스에서 프로세스를 백그라운드로 실행하려면 명령어 뒤에 &를 붙이면 된다.
 - &를 붙이면 백그라운드로 프로세스가 실행되긴 하지만, 사용자가 로그아웃하면 터미널에서 실행한 백그라운드 프로세스가 함께 종료될 수도 있다.
 - 터미널을 종료해도 백그라운드 프로세스가 계속 실행되게 하려면 추가로 nohup 명령어와 &를 함께 사용한다.
 - nohub 명령어로 실행한 프로세스가 콘솔에 출력하는 내용은 기본적으로 nohup.out 파일에 기록된다. 다른 파일에 기록하고 싶다면 리눅스의 리디렉션을 사용하면 된다.
```bash
# 백그라운드 실행
nohup java -Dserver.port=9090 -jar server.jar &

# 콘솔 출력 파일 변경
nohup java -Dserver.port=9090 -jar server.jar > server.log 2>&1 &
```
<br/>

## 3. 디스크 용량 관리

디스크가 가득 차서 발생하는 문제를 방지하려면, 서버 모니터링 도구가 디스크 사용률에 따른 알림 기능을 제공해야 한다. 보통은 경고와 위험을 나타내는 2개의 사용률을 설정한다. 예를 들어 사용률이 80%를 넘기면 경고 알림을 보내고 90%를 넘기면 위험 알림을 보낸다.

```bash
# 파티션 사용률 확인
$ df -h

# 디렉토리별 사용량 확인 (-s: 하위 디렉토리의 용량 합과 파일 크기, -h: 바이트 대신 K,M,G 단위 용량 표시)
$ du -sh ./*
```
<br/>

 - `로그 파일`
    - 나중에 문제가 생겼을 때 원인을 분석하기 위해 로그를 남긴다.
    - 로그를 남기는 위치는 다양한다. 로컬 서버의 디스크에 남기거나 별도의 수집 서버에 로그를 남긴다.
    - 로그 파일을 정리하는 가장 쉬운 방법은 오래된 로그를 삭제하는 것이다. 예를 들어 최대 90일 까지의 로그만 로컬 디스크에 저장하고, 이전 로그는 삭제한다.
    - 보관이 필요하면 NAS나 S3 같은 별도 저장소로 로그 파일을 백업하고 삭제한다. 오래된 로그 파일을 삭제해서 디스크 여유 공간을 일정 크기로 유지한다.
    - 로그 파일을 압축해서 추가 공간을 확보할 수도 있다. 로그와 텍스트 파일은 압축 효율이 높으므로 일정 기간이 지난 로그 파일을 압축해서 보관하면 로그가 사용하는 디스크 용량을 상당히 줄일 수 있다.
 - `파일 저장(임시 파일 등)`
    - 파일 저장 기능도 디스크 용량을 증가시킨다.
    - 클라이언트가 전송한 파일을 로컬에 임시로 보관한 뒤에 파일 서버로 업로드하는 기능은 로컬 디스크에 임시로 생성한 파일을 남긴다.
    - 임시로 쌓이는 파일도 일정 시간이 지나면 삭제해서 디스크 용량이 불필요하게 증가하는 것을 방지하자.
```BASH
# find 명령어로 오래된 파일 삭제하기
$ find ./logs -mtime +29 -type f -delete
```

 - `디렉토리 파일 갯수 분리`
    - 한 디렉토리에 저장되는 파일 개수가 증가하면 해당 디렉토리에 대한 파일 탐색 속도가 급격히 느려진다.
    - 이 문제를 방지하기 위해 한 디렉토리에 저장하는 파일 개수를 일정 개수 이하로 제한해야 한다.
    - 흔히 사용하는 방법으로는 일자나 시간 기준으로 폴더를 생성하는 것이다. (/files/2025/08/12)
 - `로그 로테이션을 적용하지 않은 로그 파일`
    - 실수로 로그 파일에 대한 로그 로테이션 처리를 하지 않았다고 가정한다. 로그 파일이 계속해서 커질 것이다.
    - 크기가 큰 로그 파일을 복사, 압축하는 작업을 운영 중인 서비스에 부담이 될 수 있다.
    - 서비스를 중지할 수 없는 상황인데 디스크 용량이 95%를 넘겼다면 심적으로 부담도 커진다.
    - 이럴 때 널 카피를 사용할 수 있다. -> 이전에 쌓인 로그가 모두 유실되지만, 용량 부족 문제를 급하게 조치할 수 있다.
```bash
# /dev/null은 널(null) 장치 파일로, 이 장치에 쓰는 데이터는 모두 버려진다.
# 널 장치 파일을 out.log 파일에 복사하는데, 이는 out.log 파일을 비우는 효과를 낸다. (파일 크기가 0이 된다.)
$ cp /dev/null out.log
```
<br/>

## 4. 파일 디스크립터 제한

프로세스는 데이터 입출력이 필요할 때 OS로부터 파일 디스크립터를 할당받는다. 예를 들어 파일 입출력이나 소켓을 이용한 네트워크 입출력을 처리할 때 파일 디스크립터를 할당받아 사용한다.

__OS는 사용자나 시스템 수준에서 생성할 수 있는 파일 디스크립터 개수를 제한한다. 프로세스는 제한된 개수의 파일 디스크립터를 초과해서 생성할 수 없다.__ 예를 들어, 사용자의 파일 디스크립터 개수 제한이 1024라면 프로세스는 파일과 소켓을 합쳐 1024개를 초과해서 열 수 없다. 따라서 동시에 1024개 이상의 클라이언트가 연결을 시도하면 "Too Many Open Files"와 같은 오류 메시지와 함께 소켓 생성에 실패한다.

이런 오류를 방지하려면, 트래픽 증가에 맞춰 미리 파일 디스크립터 개수 제한을 확인하고 늘려야 한다.

```bash
# 사용자의 파일 디스크립터 개수 제한 확인 (open files 갯수 확인)
$ ulimit -a
$ ulimit -n

# 사용자의 기본 파일 디스크립터 제한 변경
# soft와 hard는 각각 사용자의 기본 값과 설정할 수 있는 최대 값을 지정한다.
$ vi /etc/security/limits.conf
* soft nofile 100000 # 모든 사용자에 대한 디스크립터를 10만으로 변경
* hard nofile 100000
```

 - `systemd로 실행되는 서비스의 파일 디스크립터 제한`
```bash
# systemd로 실행되는 서비스의 파일 디스크립터 제한은 systemctl show 명령어로 확인
$ systemctl show -p DefaultLimitNOFILE
DefaultLimitNOFILE=524288

# systemd로 실행되는 서비스는 ulimit이나 limits.conf 파일에 설정한 값을 사용하지 않는다.
# /etc/systemd/system.conf 파일에 있는 DefaultLimitNOFILE 값을 서비스의 기본 파일 디스크립터 제한 값으로 사용한다.
$ vi /etc/systemd/system.conf

# system.conf 파일을 수정하면 systemctl daemon-reload 명령어로 설정을 반영한다.
$ systemctl daemon-reload
```

 - `프로세스가 가질 수 있는 파일 디스크립터 개수 제한`
    - 이 값은 충분히 큰 값을 가지므로 변경할 필요는 없다.
    - 더 큰 값이 필요하다면 /etc/sysctl.conf 파일에 fs.nr_open 설정을 변경한다.
```bash
$ sysctl fs.nr_open
```

 - `시스템 전체 파일 디스크립터 개수 제한`
    - 이 값이 충분히 크다면 늘릴 필요가 없다.
    - 변경하고 싶다면 /etc/sysctl.conf 파일에 fs.file-max 설정을 변경한다.
```bash
$ sysctl fs.file-max
```

 - `실제 프로세스가 사용 중인 파일 디스크립터 개수 확인`
```bash
$ lsof -p {PID}
$ lsof -p {PID} | wc -l
```
<br/>

## 5. 시간 맞추기

서버를 운영할 때는 시간 동기화에 신경 써야 한다. 컴퓨터가 관리하는 시간과 실제 세계의 시간 사이에는 조금씩 오차가 생긴다.

서버 시간이 틀어지는 것을 방지하려면 chrony나 ntp 같은 서비스를 이용해서 주기적으로 서버 시간을 맞춰야 한다.

<br/>

## 6. 크론으로 스케줄링하기

서버를 운영하면 일정 시간마다 해야 할 작업이 생긴다.

 - 매일 0시 5분에 90일 이상된 로그 파일을 삭제한다.
 - 매일 0시 10분에 10일 이상된 로그 파일을 압축한다.
 - 매주 일요일 4시에 DB를 풀백업한다.
 - 매주 일요일 6시에 DB 풀백업 파일을 S3에 업로드한다.

이런 작업을 실행하기에 적합한 도구가 크론이다. 크론은 리눅스를 포함한 유닉스 계열 OS의 시간 기반 스케줄러이다. 크론은 크론탭에 정의된 스케줄에 맞춰 작업을 실행한다.

```bash
# 크론탭 작업 목록 확인
$ crontab -l

# 크론탭 변경
$ crontab -e
# 분(0-59) 시(0-23) 일(1-31) 월(1-12) 요일(0-6, 0이 일요일, 6이 토요일)
0 0 * * *  # : 매일 0시 0분
30 1 1 * * # : 매월 1일 1시 30분
5 4 * * 0  # : 매주 일요일 4시 5분

# 콤마로 구분해서 개별 값 지정
0 1,2,3 * * * # : 매일 1시 0분, 2시 0분, 3시 0분
0,30 5 * * *  # : 매일 5시 0분, 5시 30분

# 구간 지정
* 30 1-3 * * * # : 매일 1시에서 3시의 매시 30분 (1시 30분, 2시 30분, 3시 30분)

# 슬래시를 이용해서 시간 간격 지정
*/10 1 * * * # : 매일 1시 0분부터 1시 50분까지 10분 간격으로 실행
0 */2 * * * # : 0시부터 2시간 간격으로 0분에 실행
```
<br/>

 - `예시`
    - 크론탭으로 실행한 명령어의 콘솔 출력을 별도 파일에 남기면 나중에 문제가 생겼을 때 원인을 분석하는 데 도움이 된다.
```bash
0 4 * * * /data/project/run.sh > /data/project/out.log 2>&1
```
<br/>

## 7. alias 등록하기

```bash
# 현재 터미널 세션에 cdweb이라는 별칭 적용
$ alias cdweb='cd /var/www/html'

# 쉘 구성 파일에 alias 등록
vi .bashrc
alias cdweb='cd /var/www/html'
alias grep='grep --color=auto'
alias ll='ls -l --color=auto'
alias ls='ls --color=auto'
```

 - `알아두기 (.bash_profile 파일과 .bashrc 파일)`
   - .bash_profile 파일과 .bashrc 파일은 bash 셸에서 사용자 환경을 구성할 때 사용되는 설정 파일이다.
      - bash_profile 파일은 사용자가 로그인할 때 한 번 실행된다. 보통 이 파일에서 PATH처럼 전체 세션에 필요한 환경 변수를 설정한다.
      - .bashrc 파일은 새로운 bash 셸을 시작하거나 터미널 창을 열 떄 실행된다. 주로 별칭과 같은 각 세션마다 적용할 설정을 이 파일에 지정한다.
      - .bash_profile 파일은 내부에서 .bashrc 파일을 실행하는 코드가 포함되어 있어, 로그인 시점에 .bashrc 설정도 함께 적용된다.

<br/>

## 8. 네트워크 정보 확인

 - `IP 정보 확인`
   - 서버의 IP 주소를 알고 싶다면 ifconfig 명령어를 사용한다.
   - ifconfig는 각 네트워크 인터페이스별로 IP 주소를 포함한 정보를 보여준다.
      - IP주소(inet), IPv6주소(inet6), MAC주소(ether)
```bash
$ ifconfig
eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST> mtu 1500
  inet .. netmask 255.255.240.0 boardcast ..
  inet6 .. prefixlen 64 scopeid 0x20<link
```
<br/>

 - `네트워크 연결 확인`
   - 서버에서 내/외부 서비스 연동시 연결이 불안정할 때가 있다. 이때, 네트워크 연결이 정상적으로 이루어지는 확인할 필요가 있다.
   - 보통 가장 먼저 확인하는 작업은 해당 서버의 특정 포트로 연결이 잘 되는지 확인하는 것이다.
```bash
# 특정 포트 연결 확인시 nc 명령어 사용
$ nc -z -v www.daum.net 443

# UDP 포트 확인
$ nc -z -u -v localhost 6100
```
<br/>

 - `사용 포트 확인`
   - netstat 명령어를 사용하면 현재 사용 중인 소켓 IP와 포트를 확인할 수 있다.
   - -l: 리스닝 서버 소켓 출력
   - -p: 소켓을 사용하는 PID/프로그램 이름 출력
   - -u: UDP 소켓 출력
   - -t: TCP 소켓 출력
   - -n: 포트나 주소를 숫자로 출력
```bash
$ netstat -lputn

# 사용중인 전체 포트 확인
$ netstat -anp | grep 12931
```
